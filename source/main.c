
#define version "dz80 - v1.04"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Z80 Disassembler by LoveBug - https://lovebyte.eu.org
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 2021-01-22 v1.04
// changes
// improve disassembler output to make it compatible with z80 assemblers
//
// todo
// add new features to map file parser and arrays for new label system
//
// bug fixes
// none
//
// known issues:
//
// 1) autogenerated data address labels are now cleared from the mark buffer if the location was later traced as opcode
// and although the Txxx: label is removed from the address field it is still shown as created after the instruction
// example ld hl, $0100; could be a data table address, label T0100: created
//
// cause:
//
// 1) currently during trace only the first byte of the instruction is marked as code but all bytes of instruction need to be marked as code
// so that the data flag removal between pass 1 and 2 can correctly detect code mark
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// 2021-01-13 v1.02
// changes
// tidy up code and added time stamps to output files
// done: opcodes 00-ff (complete)
// done: opcodes 00-ff dd/fd prefix (complete)
// done: opcodes cb xx (complete)
// done: opcodes cb xx dd|fd prefix (complete)
// done: opcodes ed xx (complete) does not have dd|fd prefix
// opcodes verified with tables from https://www.ime.usp.br/~einar/z80table/
//
// todo
// add new features to map file parser
//
// .codebase 0x0000 ; defines the start address for the binary input file
//
// .trace 0x0000 .reset ; trace from these locations
// .trace 0x0038 .interrupt
// .trace 0x0066 .nmiInterrupt
//
// .data 0x2000 .musicTable ; define a label for a data table
//
// ; create some substitutions for values / addresses in the code
//
// .const 0xb000 soundPort1
// .const 0xc000 soundPort2
// .const 0x67ff stackTop
// .const 0xd000 videoRam
// .const 0x400  videoRamSize
//
//-----------------------------------------------------------------------------
//
// known issues
// autogenerated data address labels are now cleared from the mark buffer if the location was later traced as opcode
// and although the .Txxx label is removed from the address field it is still shown as created after the instruction
// example ld hl, $0100; could be a data table address, label T0100 created
//
//-----------------------------------------------------------------------------

// required
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// global stuff
#define false 0
#define true 1

// maximum number of entrys in map file
#define mapMaxLength 1000

// maximum line length when reading map file text
#define textMaxLength 1000

// marker for end of map file
#define mapEnd -1

// stack buffer size 16K
#define stackBufferSize 0x4000

// buffer for stack
int stackBuffer[stackBufferSize];

// program counter and stack pointer
unsigned int programCounter;
int stackPointer;

// filenames
char *binInputName, *mapInputName, *traceOutputName, *assemblerOutputName;

// flags for marking area as empty, opcode, jump address label, data addres label
#define markEmpty 0
#define markOpcode 1
#define markJump 2
#define markData 4

// disassembly mode
#define modeTrace 0
#define modeGenerate 1

// code buffer size 64K
#define codeBufferSize 0x10000

// allocate buffers for code/data and flags
// allow 3 more bytes because the disassembler pulls 4 bytes at a time (max z80 instruction size) allowing for last byte to not overflow buffer
unsigned int codeBuffer[codeBufferSize + 3];
unsigned int markBuffer[codeBufferSize];

// start and end address of code
int codeStart, codeEnd;

// storage for z80 instruction data bytes
unsigned int dataByte[3];



//---------------------------------
// push program counter onto stack
//---------------------------------

void push(void)
{

	// store program counter on stack
	stackBuffer[stackPointer] = programCounter;

	// increment program counter
	stackPointer++;

	// exit program if stack buffer overrun
	if(stackPointer >= stackBufferSize)
	{
		fprintf(stderr, "**** issue **** out of stack space\n");
		exit(EXIT_FAILURE);
	}

	return;
}



//--------------------------------
// pop program counter from stack
//--------------------------------

void pop(void)
{
	// decrement stack pointer
	stackPointer--;

	// exit if stack buffer underrun (end of current trace)
	if(stackPointer < 0)
		return;

	// get program counter from stack
	programCounter = stackBuffer[stackPointer];

	return;
}



//-----------------------------------------------------------------------------
// calculate address from program counter + relative displacement
//-----------------------------------------------------------------------------

unsigned int relative(unsigned int displacement)
{

	if(displacement <= 127)
		return programCounter + displacement;
	else
		return programCounter + displacement - 256;
}



//-----------------------------------------------------------------------------
// check dd and fd prefix flags, give warning if not valid for instruction
//-----------------------------------------------------------------------------

// prefix flags
int prefixDD, prefixFD;

void prefixCheck(FILE *output)
{
	// if dd flag set
	if(prefixDD)
		// give warning about it
		fprintf(output, "\tdb $dd; **** strange **** prefix has no effect on following instruction\n");

	//if fd flag set
	if(prefixFD)
		// give warning about it
		fprintf(output, "\tdb $fd; **** strange **** prefix has no effect on following instruction\n");
}



//-------------------------------------------------------------------------------------------------------------------------------------------------------------------
// disassembler
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------

void disassemble(FILE *output, int disassemblerAddress, int disassemblerMode)
{

	// z80 register tables
	const char * const regLowHL[] = {"b", "c", "d", "e", "h", "l", "(hl)", "a"};
	const char * const regLowIX[] = {"b", "c", "d", "e", "ixh", "ixl", "ix", "a"};
	const char * const regLowIY[] = {"b", "c", "d", "e", "iyh", "iyl", "iy", "a"};
	const char * const regLowCB[] = {" -> b", " -> c", " -> d", " -> e", " -> h", " -> l", "", " -> a"};

	const char * const regHighAF[] = {"bc", "de", "hl", "af"};
	const char * const regHighAFIX[] = {"bc", "de", "ix", "af"};
	const char * const regHighAFIY[] = {"bc", "de", "iy", "af"};

	const char * const regHighSP[] = {"bc", "de", "hl", "sp"};
	const char * const regHighSPIX[] = {"bc", "de", "ix", "sp"};
	const char * const regHighSPIY[] = {"bc", "de", "iy", "sp"};

	// z80 condition table
	const char * const condition[] = {"nz", "z", "nc", "c", "po", "pe", "p", "m"};

	// init program counter and stack pointer
	programCounter = disassemblerAddress;
	stackPointer = 0;

	// init prefix flags
	prefixDD = false;
	prefixFD = false;

	// 16 bit word used for jump address and data
	unsigned int dataWord;

	// bit masked indexes for tables
	int	index210, index43, index543, index54, indexCB210, indexCB543, indexCB54, indexPCB210, indexPCB543;

	// byte counter for db data tables
	int byteCounter = 0;

	// main loop while not finished
	while(stackPointer >= 0 && programCounter < codeEnd)
	{

		// if trace mode
		if(disassemblerMode == modeTrace)
		{
			// while stack pointer is still within stack buffer and this location has already been traced
			while(stackPointer >= 0 && (markBuffer[programCounter - codeStart] & markOpcode) != 0)
			{
				// pop the program counter from the stack and test again
				pop();
			}
		}

		// if not finished
		if(stackPointer >= 0)
		{

			// if trace mode
			if(disassemblerMode == modeTrace)
			{
				// mark location as code
				markBuffer[programCounter - codeStart] |= markOpcode;

				// mark location as not data
				markBuffer[programCounter - codeStart] &= ~markData;

				// if dd|fd flag not set
				if(!prefixDD && !prefixFD)
					// then output an address label
					fprintf(output, "J%04x: ", programCounter);
			}

			// if generate mode and location marked as a data label or jump label
			if(disassemblerMode == modeGenerate && ((markBuffer[programCounter - codeStart] & markJump) != 0 || (markBuffer[programCounter - codeStart] & markData) != 0))
			{
				// if db byte counter != 0
				if(byteCounter != 0)
				{
					// reset byte counter and print an extra newline
					byteCounter = 0;
					fprintf(output, "\n");
				}

				// if location marked as jump adress then output a jump label
				if((markBuffer[programCounter - codeStart] & markJump) != 0)
					fprintf(output, "\nJ%04x:", programCounter);

				// if location marked as data address then output an address label
				if((markBuffer[programCounter - codeStart] & markData) != 0)
					fprintf(output, "\nT%04x:", programCounter);

				fprintf(output, "\n");

			}

			// grab 4 bytes from buffer (maximum z80 instruction length)
			dataByte[0] = codeBuffer[programCounter - codeStart];
			dataByte[1] = codeBuffer[programCounter - codeStart + 1];
			dataByte[2] = codeBuffer[programCounter - codeStart + 2];
			dataByte[3] = codeBuffer[programCounter - codeStart + 3];

			// precalculate bit masked table indexes
			index210 = dataByte[0] & 7;
			index43 = (dataByte[0] >> 3) & 3;
			index543 = (dataByte[0] >> 3) & 7;
			index54 = (dataByte[0] >> 4) & 3;

			indexCB210 = dataByte[1] & 7;
			indexCB543 = (dataByte[1] >> 3) & 7;
			indexCB54 = (dataByte[1] >> 4) & 3;

			indexPCB210 = dataByte[2] & 7;
			indexPCB543 = (dataByte[2] >> 3) & 7;

			// if location is marked as code then attempt to decode it
			if((markBuffer[programCounter - codeStart] & markOpcode) != 0)
			{

				//-------------------------------------------------------------------------------------------------------------
				// opcode decoder
				//-------------------------------------------------------------------------------------------------------------
				while(true)
				{

//--------------------------------------------------------------------------------------------------------------------------------------------------
//																	$dd $fd $ed check before instruction decoding
//--------------------------------------------------------------------------------------------------------------------------------------------------


					//------------------------------------------------------------------------------
					// $dd prefix set dd flag and clear fd flag also give warning if previously set
					//------------------------------------------------------------------------------

					if(dataByte[0] == 0xdd)
					{
						programCounter += 1;

						prefixCheck(output);

						prefixDD = true;
						prefixFD = false;

						break;
					}

					//-------------------------------------------------------------------------
					// $fd prefix set fd flag and clear dd flag
					//-------------------------------------------------------------------------

					if(dataByte[0] == 0xfd)
					{
						programCounter += 1;

						prefixCheck(output);

						prefixDD = false;
						prefixFD = true;

						break;
					}

					//--------------------------------------------------------------------------------------------------------------------------------------------------------
					// $ed prefix give warning if dd or fd flags are active and clear them, do not advance program counter/break as $ed instructions need still to be decoded
					//--------------------------------------------------------------------------------------------------------------------------------------------------------

					if(dataByte[0] == 0xed)
					{

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// clear both dd and fd prefix
						prefixDD = false;
						prefixFD = false;

					}

//--------------------------------------------------------------------------------------------------------------------------------------------------
//																	$00 - $ff code set except $cb and $ed
//--------------------------------------------------------------------------------------------------------------------------------------------------


					//-------------------------------------------------------------------------
					//* $00 nop
					//-------------------------------------------------------------------------

					if(dataByte[0] == 0x00)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tnop\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(01 11 21 31) ld regHighSP|SPIX|SPIY[54], nn
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xcf) == 0x01)
					{
						programCounter += 3;

						// get 16 bit nn
						dataWord = dataByte[2] * 256 + dataByte[1];

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tld %s, $%04x", regHighSP[index54], dataWord);

						if(prefixDD)
							fprintf(output, "\tld %s, $%04x", regHighSPIX[index54], dataWord);

						if(prefixFD)
							fprintf(output, "\tld %s, $%04x", regHighSPIY[index54], dataWord);

						// if nn is within code range then it could be a lookup table address
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// if trace mode
							if(disassemblerMode == modeTrace)
							{
								// add data address flag
								markBuffer[dataWord - codeStart] |= markData;
							}

							// if data mark found
							if((markBuffer[dataWord - codeStart] & markData) != 0);
							{
								// make a note in assembler output
								fprintf(output, "\t; could be a data table address, label T%04x: created", dataWord);
							}

						}

						fprintf(output, "\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $02 ld (bc),a
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x02)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tld (bc), a\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(03 13 23 33) inc regHighSP|SPIX|SPIY[54]
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xcf) == 0x03)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tinc %s\n", regHighSP[index54]);

						if(prefixDD)
							fprintf(output, "\tinc %s\n", regHighSPIX[index54]);

						if(prefixFD)
							fprintf(output, "\tinc %s\n", regHighSPIY[index54]);

						break;
					}

					//-------------------------------------------------------------------------
					//* $(04 0c 14 1c 24 2c 34 3c) inc regLowHL|IX|IY[543]
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xc7) == 0x04)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tinc %s\n", regLowHL[index543]);

						if(prefixDD)
						{
							if(index543 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tinc (%s + $%02x)\n", regLowIX[index543], dataByte[1]);
							}
							else
								fprintf(output, "\tinc %s\n", regLowIX[index543]);
						}

						if(prefixFD)
						{
							if(index543 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tinc (%s + $%02x)\n", regLowIY[index543], dataByte[1]);
							}
							else
								fprintf(output, "\tinc %s\n", regLowIY[index543]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(05 0d 15 1d 25 2d 35 3d) dec regLowHL|IX|IY[543]
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xc7) == 0x05)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tdec %s\n", regLowHL[index543]);

						if(prefixDD)
						{
							if(index543 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tdec (%s + $%02x)\n", regLowIX[index543], dataByte[1]);
							}
							else
								fprintf(output, "\tdec %s\n", regLowIX[index543]);
						}

						if(prefixFD)
						{
							if(index543 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tdec (%s + $%02x)\n", regLowIY[index543], dataByte[1]);
							}
							else
								fprintf(output, "\tdec %s\n", regLowIY[index543]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(06 0e 16 1e 26 2e 36 3e) ld regLowHL|IX|IY[543], n
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xc7) == 0x06)
					{
						programCounter += 2;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tld %s, $%02x\n", regLowHL[index543], dataByte[1]);

						if(prefixDD)
						{
							if(index543 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tld (%s + $%02x), $%02x\n", regLowIX[index543], dataByte[1], dataByte[2]);
							}
							else
								fprintf(output, "\tld %s, $%02x\n", regLowIX[index543], dataByte[1]);

						}

						if(prefixFD)
						{
							if(index543 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tld (%s + $%02x), $%02x\n", regLowIY[index543], dataByte[1], dataByte[2]);
							}
							else
								fprintf(output, "\tld %s, $%02x\n", regLowIY[index543], dataByte[1]);
						}

						break;
					}

					//--------------------------------------------------------------------------
					//* $07 rlca
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x07)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\trlca\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $08 ex af, af'
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x08)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tex af, af'\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(09 19 29 39) add (hl|ix|iy), regHighSP|SPIX|SPIY[54]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xcf) == 0x09)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tadd hl, %s\n", regHighSP[index54]);

						if(prefixDD)
							fprintf(output, "\tadd ix, %s\n", regHighSPIX[index54]);

						if(prefixFD)
							fprintf(output, "\tadd iy, %s\n", regHighSPIY[index54]);

						break;
					}

					//--------------------------------------------------------------------------
					//* $0a ld a, (bc)
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x0a)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tld a, (bc)\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(0b 1b 2b 3b) dec regHighSP|SPIX|SPIY[54]
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xcf) == 0x0b)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tdec %s\n", regHighSP[index54]);

						if(prefixDD)
							fprintf(output, "\tdec %s\n", regHighSPIX[index54]);

						if(prefixFD)
							fprintf(output, "\tdec %s\n", regHighSPIY[index54]);

						break;
					}

					//--------------------------------------------------------------------------
					//* $0f rrca
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x0f)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\trrca\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $10 djnz relative n
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x10)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get relative jump address
						dataWord = relative(dataByte[1]);

						fprintf(output, "\tdjnz J%04x", dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// and we're in trace mode
							if(disassemblerMode == modeTrace)
							{
								// then add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// push program counter
								push();

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $12 ld (de), a
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x12)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tld (de), a\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $17 rla
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x17)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\trla\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $18 jr relative n (unconditional jump, dont push pc)
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x18)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get relative jump address
						dataWord = relative(dataByte[1]);

						fprintf(output, "\tjr J%04x", dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// and we're in trace mode
							if(disassemblerMode == modeTrace)
							{
								// add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $1a ld a, (de)
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x1a)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tld a, (de)\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $1f rra
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x1f)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\trra\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(20 28 30 38) jr condition[43] relative n
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xE7) == 0x20)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get relative jump address
						dataWord = relative(dataByte[1]);

						fprintf(output, "\tjr %s, J%04x", condition[index43], dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// and we're in trace mode
							if(disassemblerMode == modeTrace)
							{
								// then add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// push program counter
								push();

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $(22) ld (nn), hl|ix|iy
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x22)
					{
						programCounter += 3;

						// get address
						dataWord = dataByte[2] * 256 + dataByte[1];

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tld ($%04x), hl\n", dataWord);

						if(prefixDD)
							fprintf(output, "\tld ($%04x), ix\n", dataWord);

						if(prefixFD)
							fprintf(output, "\tld ($%04x), iy\n", dataWord);

						break;
					}

					//--------------------------------------------------------------------------
					//* $27 daa
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x27)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tdaa\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $2a ld hl|ix|iy, (nn)
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x2a)
					{
						programCounter += 3;

						// get address
						dataWord = dataByte[2] * 256 + dataByte[1];

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tld hl, ($%04x)\n", dataWord);

						if(prefixDD)
							fprintf(output, "\tld ix, ($%04x)\n", dataWord);

						if(prefixFD)
							fprintf(output, "\tld iy, ($%04x)\n", dataWord);

						break;
					}

					//--------------------------------------------------------------------------
					//* $2f cpl
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x2f)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tcpl\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $32 ld (nn), a
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x32)
					{
						programCounter += 3;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get address
						dataWord = dataByte[2] * 256 + dataByte[1];

						fprintf(output, "\tld ($%04x), a\n", dataWord);
						break;
					}

					//--------------------------------------------------------------------------
					//* $37 scf
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x37)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tscf\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $3a ld a, (nn)
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x3a)
					{
						programCounter += 3;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get address
						dataWord = dataByte[2] * 256 + dataByte[1];

						fprintf(output, "\tld a, ($%04x)\n", dataWord);
						break;
					}

					//--------------------------------------------------------------------------
					//* $3f ccf
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x3f)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tccf\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $76 halt
					// this instruction falls within the 40 - 7f opcode set so capture it first
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0x76)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\thalt\t; wait for interrupt then continue\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(40 - 7f) ld regLowHL|IX|IY[543], regLowHL|IX|IY[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xc0) == 0x40)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tld %s, %s\n", regLowHL[index543], regLowHL[index210]);

						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tld %s, (%s + $%02x)\n", regLowIX[index543], regLowIX[index210], dataByte[1]);
							}
							else
								fprintf(output, "\tld %s, %s\n", regLowIX[index543], regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tld %s, (%s + $%02x)\n", regLowIY[index543], regLowIY[index210], dataByte[1]);
							}
							else
								fprintf(output, "\tld %s, %s\n", regLowIY[index543], regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(80 - 87) add regLowHL|IX|IY[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0x80)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tadd %s\n", regLowHL[index210]);

						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tadd (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tadd %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tadd (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tadd %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(88 - 8f) adc regLowHL|IX|IY[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0x88)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tadc %s\n", regLowHL[index210]);

						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tadc (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tadc %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tadc (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tadc %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* (90 - 97) sub regLowHL[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0x90)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tsub %s\n", regLowHL[index210]);


						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tsub (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tsub %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tsub (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tsub %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(98 - 9f) sbc regLowHL[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0x98)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tsbc %s\n", regLowHL[index210]);


						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tsbc (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tsbc %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tsbc (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tsbc %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(a0 - a7) and regLowHL[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0xa0)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tand %s\n", regLowHL[index210]);

						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tand (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tand %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tand (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tand %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(a8 - af) xor regLowHL[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0xa8)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\txor %s\n", regLowHL[index210]);


						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\txor (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\txor %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\txor (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\txor %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(b0 - b7) or regLowHL[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0xb0)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tor %s\n", regLowHL[index210]);


						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tor (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tor %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tor (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tor %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(b8 - bf) cp regLowHL[210]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xf8) == 0xb8)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tcp %s\n", regLowHL[index210]);


						if(prefixDD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tcp (%s + $%02x)\n", regLowIX[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tcp %s\n", regLowIX[index210]);
						}

						if(prefixFD)
						{
							if(index210 == 6)
							{
								programCounter += 1;
								fprintf(output, "\tcp (%s + $%02x)\n", regLowIY[index210], dataByte[1]);
							}
							else
							fprintf(output, "\tcp %s\n", regLowIY[index210]);
						}

						break;
					}

					//-------------------------------------------------------------------------
					//* $(c0 c8 d0 d8 e0 e8 f0 f8) ret condition[543]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xc7) == 0xc0)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tret %s\n", condition[index543]);
						break;
					}

					//-------------------------------------------------------------------------
					//* $(c1 d1 e1 f1) pop regHighAF|AFIX|AFIY[54]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xcf) == 0xc1)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tpop %s\n", regHighAF[index54]);

						if(prefixDD)
							fprintf(output, "\tpop %s\n", regHighAFIX[index54]);

						if(prefixFD)
							fprintf(output, "\tpop %s\n", regHighAFIY[index54]);

						break;
					}

					//-------------------------------------------------------------------------
					//* $(c2 ca d2 da e2 ea f2 fa) jp condition[543] nn
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xc7) == 0xc2)
					{
						programCounter += 3;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get jump address
						dataWord = dataByte[2] * 256 + dataByte[1];
						fprintf(output, "\tjp %s, J%04x", condition[index543], dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// if trace mode
							if(disassemblerMode == modeTrace)
							{
								// then push program counter
								push();

								// add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $c3 jp nn (jump unconditional, dont push pc)
					//-------------------------------------------------------------------------
					if(dataByte[0] == 0xc3)
					{
						programCounter += 3;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get jump address
						dataWord = dataByte[2] * 256 + dataByte[1];
						fprintf(output, "\tjp J%04x", dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// if trace mode
							if(disassemblerMode == modeTrace)
							{
								// add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(c4 cc d4 dc e4 ec f4 fc) call condition[543] nn
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xc7) == 0xc4)
					{
						programCounter += 3;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get jump address
						dataWord = dataByte[2] * 256 + dataByte[1];
						fprintf(output, "\tcall %s, J%04x", condition[index543], dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// if trace mode
							if(disassemblerMode == modeTrace)
							{
								// then push program counter
								push();

								// add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $(c5 d5 e5 f5) push regHighAF|AFIX|AFIY[54]
					//-------------------------------------------------------------------------
					if((dataByte[0] & 0xcf) == 0xc5)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tpush %s\n", regHighAF[index54]);

						if(prefixDD)
							fprintf(output, "\tpush %s\n", regHighAFIX[index54]);

						if(prefixFD)
							fprintf(output, "\tpush %s\n", regHighAFIY[index54]);

						break;
					}

					//--------------------------------------------------------------------------
					//* $c6 add a, n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xc6)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tadd a, $%02x\n", dataByte[1]);
						break;
					}

					//-------------------------------------------------------------------------
					//* $(c7 cf d7 df e7 ef f7 ff) rst (00 - 38) 543
					//-------------------------------------------------------------------------

					if((dataByte[0] & 0xc7) == 0xc7)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get jump address
						dataWord = dataByte[0] & 0x38;

						fprintf(output, "\trst $%02x", dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// if trace mode
							if(disassemblerMode == modeTrace)
							{
								// then push program counter
								push();

								// add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//-------------------------------------------------------------------------
					//* $c9 ret
					//-------------------------------------------------------------------------
					if(dataByte[0] == 0xc9)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tret\n");

						// if trace mode then pop program counter
						if(disassemblerMode == modeTrace)
							pop();

						break;
					}

					//-------------------------------------------------------------------------
					//* $cd nn call nn
					//-------------------------------------------------------------------------
					if(dataByte[0] == 0xcd)
					{
						programCounter += 3;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						// get jump address
						dataWord = dataByte[2] * 256 + dataByte[1];
						fprintf(output, "\tcall J%04x", dataWord);

						// if jump address is within code range
						if(dataWord >= codeStart && dataWord < codeEnd)
						{
							// if trace mode
							if(disassemblerMode == modeTrace)
							{
								// then add address label flag
								markBuffer[dataWord - codeStart] |= markJump;

								// push program counter
								push();

								// and jump to new address
								programCounter = dataWord;
							}
						}
						// else jump is outside code area
						else
							// so give warning
							fprintf(output, "\t; **** issue **** address outside of code area");

						fprintf(output, "\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ce adc a, n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xce)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tadc a, $%02x\n", dataByte[1]);
						break;
					}

					//--------------------------------------------------------------------------
					//* $d3 out (n), a
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xd3)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tout ($%02x), a\n", dataByte[1]);
						break;
					}

					//--------------------------------------------------------------------------
					//* $d6 sub n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xd6)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tsub $%02x\n", dataByte[1]);
						break;
					}

					//--------------------------------------------------------------------------
					//* $d9 exx
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xd9)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\texx\t; exchange bc de hl <- -> bc' de' hl'\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $db in a, (n)
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xdb)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tin a, ($%02x)\n", dataByte[1]);
						break;
					}

					//--------------------------------------------------------------------------
					//* $de sbc a, n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xde)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tsbc a, $%02x\n", dataByte[1]);
						break;
					}

					//--------------------------------------------------------------------------
					//* $e3 ex (sp), hl|ix|iy
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xe3)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tex (sp), hl\n");

						if(prefixDD)
							fprintf(output, "\tex (sp), ix\n");

						if(prefixFD)
							fprintf(output, "\tex (sp), iy\n");

						break;
					}

					//--------------------------------------------------------------------------
					//* $e6 and n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xe6)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tand $%02x\n", dataByte[1]);
						break;
					}

					//-------------------------------------------------------------------------
					//* $e9 jp (hl|ix|iy) (unable to trace unknown jump)
					//-------------------------------------------------------------------------
					if(dataByte[0] == 0xe9)
					{
						// make a note of the address
						dataWord = programCounter;

						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tjp (hl)\t; **** issue **** untraceable jump, value of hl is unknown\n");

						if(prefixDD)
							fprintf(output, "\tjp (ix)\t; **** issue **** untraceable jump, value of ix is unknown\n");

						if(prefixFD)
							fprintf(output, "\tjp (iy)\t; **** issue **** untraceable jump, value of iy is unknown\n");

						// if trace mode then pop program counter
						if(disassemblerMode == modeTrace)
						{
							fprintf(stderr, "**** issue **** %s untraceable jump at J%04x, popping return address and continuing\n", traceOutputName, programCounter);
							pop();
						}

						break;
					}

					//--------------------------------------------------------------------------
					//* $eb ex de, hl (uneffected by dd|fd prefix)
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xeb)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tex de, hl\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ee xor n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xee)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\txor $%02x\n", dataByte[1]);
						break;
					}

					//--------------------------------------------------------------------------
					//* $f3 di
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0xf3)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tdi\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $f6 or n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xf6)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tor $%02x\n", dataByte[1]);
						break;
					}

					//--------------------------------------------------------------------------
					//* $f9 ld sp, hl|ix|iy
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0xf9)
					{
						programCounter += 1;

						if(!prefixDD && !prefixFD)
							fprintf(output, "\tld sp, hl\n");

						if(prefixDD)
							fprintf(output, "\tld sp, ix\n");

						if(prefixFD)
							fprintf(output, "\tld sp, iy\n");

						break;
					}

					//--------------------------------------------------------------------------
					//* $fb ei
					//--------------------------------------------------------------------------

					if(dataByte[0] == 0xfb)
					{
						programCounter += 1;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tei\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $fe cp n
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xfe)
					{
						programCounter += 2;

						// check dd and fd prefix flags (no effect on this opcode)
						prefixCheck(output);

						fprintf(output, "\tcp $%02x\n", dataByte[1]);
						break;
					}



//--------------------------------------------------------------------------------------------------------------------------------------------------
//																	$cb code set
//--------------------------------------------------------------------------------------------------------------------------------------------------

					//--------------------------------------------------------------------------------
					//* $cb (00-07) rlc regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x00)
							{
								programCounter += 2;
								fprintf(output, "\trlc %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x00)
							{

								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\trlc (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\trlc (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------------
					//* $cb (08-0f) rrc regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x08)
							{
								programCounter += 2;
								fprintf(output, "\trrc %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x08)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\trrc (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\trrc (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb (10-17) rl regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x10)
							{
								programCounter += 2;
								fprintf(output, "\trl %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x10)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\trl (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\trl (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb (18-1f) rr regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x18)
							{
								programCounter += 2;
								fprintf(output, "\trr %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x18)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\trr (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\trr (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb (20-27) sla regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x20)
							{
								programCounter += 2;
								fprintf(output, "\tsla %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x20)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\tsla (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\tsla (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb (28-2f) sra regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x28)
							{
								programCounter += 2;
								fprintf(output, "\tsra %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x28)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\tsra (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\tsra (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					// $cb 30-37 sls regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x30)
							{
								programCounter += 2;
								fprintf(output, "\tsls %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x30)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\tsls (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\tsls (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb 38-3f srl regLowHL[CB210]|(ix+n)regLowCB[PCB210]|(iy+n)regLowCB[PCB210]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xf8) == 0x38)
							{
								programCounter += 2;
								fprintf(output, "\tsrl %s\n", regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xf8) == 0x38)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\tsrl (ix + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\tsrl (iy + $%02x)%s\n", dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb (40-7f) bit N543, regLowHL[N210]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xc0) == 0x40)
							{
								programCounter += 2;
								fprintf(output, "\tbit %d, %s\n", indexCB543, regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xc0) == 0x40)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\tbit %d, (ix + $%02x)\n", indexPCB543, dataByte[1]);

								if(prefixFD)
									fprintf(output, "\tbit %d, (iy + $%02x)\n", indexPCB543, dataByte[1]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb (80-bf) res
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xc0) == 0x80)
							{
								programCounter += 2;
								fprintf(output, "\tres %d, %s\n", indexCB543, regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xc0) == 0x80)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\tres %d, (ix + $%02x)%s\n", indexPCB543, dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\tres %d, (iy + $%02x)%s\n", indexPCB543, dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

					//--------------------------------------------------------------------------
					//* $cb (c0-ff) set
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xcb)
					{
						// if no prefix
						if(!prefixDD && !prefixFD)
						{
							// then check byte 1 for opcode
							if((dataByte[1] & 0xc0) == 0xc0)
							{
								programCounter += 2;
								fprintf(output, "\tset %d, %s\n", indexCB543, regLowHL[indexCB210]);
								break;
							}
						}
						// else its a prefix
						else
						{
							// so check byte 2 for opcode
							if((dataByte[2] & 0xc0) == 0xc0)
							{
								programCounter += 3;

								if(prefixDD)
									fprintf(output, "\tset %d, (ix + $%02x)%s\n", indexPCB543, dataByte[1], regLowCB[indexPCB210]);

								if(prefixFD)
									fprintf(output, "\tset %d, (iy + $%02x)%s\n", indexPCB543, dataByte[1], regLowCB[indexPCB210]);

								break;
							}
						}
					}

//--------------------------------------------------------------------------------------------------------------------------------------------------
//																	$ed code set, these codes are uneffected by dd|fd prefix
//--------------------------------------------------------------------------------------------------------------------------------------------------

					//--------------------------------------------------------------------------
					//* $ed 00-3f nop
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xc0) == 0x00)
						{
							programCounter += 2;

							fprintf(output, "\tnop\n");

							break;
						}
					}

					//------------------------------------------------------------------------------
					//* $ed (40 48 50 58 60 68 70 78) in regLowHL[N543], (c)
					//------------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xc7) == 0x40)
						{
							programCounter += 2;

							// special case for index == 6 (no register used, only sets cpu flags)
							if(indexCB543 == 6)
								fprintf(output, "\tin (c)\t; no register used, only sets cpu flags\n");

							// else use normal registers
							else
								fprintf(output, "\tin %s, (c)\n", regLowHL[indexCB543]);

							break;
						}
					}

					//-------------------------------------------------------------------------------
					//* $ed (41 49 51 59 61 69 71 79) out (c), regLowHL[N543]
					//-------------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xc7) == 0x41)
						{
							programCounter += 2;

							// special case for index == 6 (no register used, outputs zero to port)
							if(indexCB543 == 6)
								fprintf(output, "\tout (c), $00\n");

							// else use normal registers
							else
								fprintf(output, "\tout (c), %s\n", regLowHL[indexCB543]);

							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (42 52 62 72) sbc hl, regHighSP[N54]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xcf) == 0x42)
						{
							programCounter += 2;

							fprintf(output, "\tsbc hl, %s\n", regHighSP[indexCB54]);
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (43 53 63 73) nn ld (nn), regHighSP[n54]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xcf) == 0x43)
						{
							programCounter += 4;

							// get address
							dataWord = dataByte[3] * 256 + dataByte[2];

							fprintf(output, "\tld ($%04x), %s\n", dataWord, regHighSP[indexCB54]);

							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (44 4c 54 5c 64 6c 74 7c) neg
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xc7) == 0x44)
						{
							programCounter += 2;

							fprintf(output, "\tneg\n");

							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (45 55 65 75) retn
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xcf) == 0x45)
						{
							programCounter += 2;

							fprintf(output, "\tretn\n");

							// if trace mode then pop program counter
							if(disassemblerMode == modeTrace)
								pop();

							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (46 4e 66 6e) im 0
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xd7) == 0x46)
						{
							programCounter += 2;

							fprintf(output, "\tim 0\n");
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed 47 ld i, a
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0x47)
					{
						programCounter += 2;

						fprintf(output, "\tld i, a\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed (4a 5a 6a 7a) adc hl, regHighSP[N54]
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xcf) == 0x4a)
						{
							programCounter += 2;

							fprintf(output, "\tadc hl, %s\n", regHighSP[indexCB54]);
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (4b 5b 6b 7b) nn ld regHighSP[N54], (nn)
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xcf) == 0x4b)
						{
							programCounter += 4;

							// get address
							dataWord = dataByte[3] * 256 + dataByte[2];

							fprintf(output, "\tld %s, ($%04x)\n", regHighSP[indexCB54], dataWord);
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (4d 5d 6d 7f) reti
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xcf) == 0x4d)
						{
							programCounter += 2;

							fprintf(output, "\treti\n");

							// if trace mode then pop program counter
							if(disassemblerMode == modeTrace)
								pop();

							break;
						}
					}

					//--------------------------------------------------------------------------
					//* ed 4f ld r, a (dram refresh counter)
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0x4f)
					{
						programCounter += 2;

						fprintf(output, "\tld r, a\t; write to z80 dram refresh counter. bits 6-0 count, bit 7 remains unchanged\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed (56 76) im 1
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xdf) == 0x56)
						{
							programCounter += 2;

							fprintf(output, "\tim 1\n");
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed 57 ld a, i
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0x57)
					{
						programCounter += 2;

						fprintf(output, "\tld a, i\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed (5e 7e) im 2
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xdf) == 0x5e)
						{
							programCounter += 2;

							fprintf(output, "\tim 2\n");
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed 5f ld a, r (dram refresh counter)
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0x5f)
					{
						programCounter += 2;

						fprintf(output, "\tld a, r\t; read z80 dram refresh counter, bits 6-0 count, bit 7 remains unchanged. usually used as a random number generator\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed 67 rrd
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0x67)
					{
						programCounter += 2;

						fprintf(output, "\trrd\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed 6f rld
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0x6f)
					{
						programCounter += 2;

						fprintf(output, "\trld\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* ed (77 7f) nop
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xf7) == 0x77)
						{
							programCounter += 2;

							fprintf(output, "\tnop\n");
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed (80-9f) nop
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xe0) == 0x80)
						{
							programCounter += 2;

							fprintf(output, "\tnop\n");
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed a0 ldi
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xa0)
					{
						programCounter += 2;

						fprintf(output, "\tldi\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed a1 cpi
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xa1)
					{
						programCounter += 2;

						fprintf(output, "\tcpi\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed a2 ini
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xa2)
					{
						programCounter += 2;

						fprintf(output, "\tini\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed a3 outi
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xa3)
					{
						programCounter += 2;

						fprintf(output, "\touti\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed (a4 a5 a6 a7 ac ad ae af b4 b5 b6 b7 bc bd be bf) nop
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xe4) == 0xa4)
						{
							programCounter += 2;

							fprintf(output, "\tnop\n");
							break;
						}
					}

					//--------------------------------------------------------------------------
					//* $ed a8 ldd
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xa8)
					{
						programCounter += 2;

						fprintf(output, "\tldd\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed a9 cpd
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xa9)
					{
						programCounter += 2;

						fprintf(output, "\tcpd\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed aa ind
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xaa)
					{
						programCounter += 2;

						fprintf(output, "\tind\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed ab outd
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xab)
					{
						programCounter += 2;

						fprintf(output, "\toutd\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed b0 ldir
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xb0)
					{
						programCounter += 2;

						fprintf(output, "\tldir\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed b1 cpir
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xb1)
					{
						programCounter += 2;

						fprintf(output, "\tcpir\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed b2 inir
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xb2)
					{
						programCounter += 2;

						fprintf(output, "\tinir\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed b3 otir
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xb3)
					{
						programCounter += 2;

						fprintf(output, "\totir\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed b8 lddr
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xb8)
					{
						programCounter += 2;

						fprintf(output, "\tlddr\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed b9 cpdr
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xb9)
					{
						programCounter += 2;

						fprintf(output, "\tcpdr\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed ba indr
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xba)
					{
						programCounter += 2;

						fprintf(output, "\tindr\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed bb otdr
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed && dataByte[1] == 0xbb)
					{
						programCounter += 2;

						fprintf(output, "\totdr\n");
						break;
					}

					//--------------------------------------------------------------------------
					//* $ed (c0-ff) nop
					//--------------------------------------------------------------------------
					if(dataByte[0] == 0xed)
					{
						if((dataByte[1] & 0xc0) == 0xc0)
						{
							programCounter += 2;

							fprintf(output, "\tnop\n");
							break;
						}
					}

//--------------------------------------------------------------------------------------------------------------------------------------------------

					//-------------------------------------------------------------
					// opcode was not decoded (invalid opcode)
					//-------------------------------------------------------------
					// this code was useful while I was writing the instruction
					// decoder but now I think that all opcodes are decoded
					// so this should never trigger, leaving it in just in case
					//-------------------------------------------------------------

					// display invalid opcode warning and bump program counter
					fprintf(output, "\tdb ");
					if(prefixDD)
						fprintf(output, "$dd, ");
					if(prefixFD)
						fprintf(output, "$fd, ");
					fprintf(output, "$%02x\t; **** issue **** invalid opcode\n", dataByte[0]);
					programCounter += 1;
					break;
				}

				// reset byte counter
				byteCounter = 0;

			}
			// else location is data
			else
			{
				// output data byte
				if(byteCounter == 0)
					fprintf(output, "\tdb ");
				else
					fprintf(output, ", ");

				fprintf(output, "$%02x", dataByte[0]);

				// bump byte counter
				byteCounter++;

				//if maximum bytes per line is reached
				if(byteCounter == 16)
				{
					// reset counter and start a new line
					byteCounter = 0;
					fprintf(output, "\n");
				}

				// bump program counter
				programCounter += 1;

			}

			// if opcode was not a dd|fd prefix
			if(dataByte[0] != 0xdd && dataByte[0] != 0xfd)
			{
				// then clear both dd and fd prefix flags
				prefixDD = false;
				prefixFD = false;

			}

			// if we got to the end of the code
			if(programCounter >= codeEnd)
			{

				// if the last opcode was dd or fd prefix
				if(dataByte[0] == 0xdd || dataByte[0] == 0xfd)
					// then output it
					fprintf(output, "\tdb $%02x\n", dataByte[0]);

				// and there is still return addresses on the stack
				if(stackPointer > 0)
				{
					// output message and put a note about it in the trace file
					fprintf(stderr, "**** issue **** %s reached code end but stack not empty, popping address and continuing\n", traceOutputName);
					fprintf(output, "\t; **** issue **** reached code end but stack not empty, popping address and continuing\n");

					// pop program counter from the stack to continue tracing
					pop();
				}

			}

		}

	}

	// final newline to tidy things up
	fprintf(output, "\n");

	return;

}

//--------------------------------------------------------------------------------------------------------------------------------------------------

//--------------
// main program
//--------------

int main(int argc, char *argv[])
{

	// get the date and time for time stamping the output
	time_t dateAndTime;
	time(&dateAndTime);

	// print instructions
	int arguments = argc;
	if(arguments < 5)
	{
		printf("----------------------------------------------------------\n");
		printf(" %s - Z80 Disassembler by LoveBug\n", version);
		printf("----------------------------------------------------------\n\n");
		printf("Usage: dz80 binInput mapInput traceOutput assemblerOutput\n\n");
		exit(EXIT_FAILURE);
	}

	// check for duplicate file names
	for(int i = 1; i < arguments; i++)
		for(int j = i + 1; j < arguments; j++)
			if(i != j)
				if(strcmp(argv[i], argv[j]) == 0)
				{
					fprintf(stderr, "**** issue **** duplicate file names\n");
					exit(EXIT_FAILURE);
				}

	// get filenames
	binInputName = argv[1];
	mapInputName = argv[2];
	traceOutputName = argv[3];
	assemblerOutputName = argv[4];

	// open binInputName in binary mode
	FILE *binInputFile = fopen(binInputName, "rb");
	if(binInputFile == NULL)
	{
		fprintf(stderr, "**** issue **** error opening %s\n", binInputName);
		exit(EXIT_FAILURE);
	}

	// get file size
	fseek(binInputFile, 0L, SEEK_END);
	int binInputSize = ftell(binInputFile);
	rewind(binInputFile);

	// check file size is larger than 64K
	if(binInputSize >= 0x10000)
	{
		fclose(binInputFile);
		fprintf(stderr, "**** issue **** %s is larger than 64K\n", binInputName);
		exit(EXIT_FAILURE);
	}

	// read code/data into buffer and clear all flags
	for(int i = 0; i < binInputSize; i++)
	{
		unsigned int dataByte = fgetc(binInputFile);
		codeBuffer[i] = dataByte;
		markBuffer[i] = markEmpty;
	}

	// close binInput file
	fclose(binInputFile);

	// open mapInputName in text mode
	FILE *mapInputFile = fopen(mapInputName, "r");
	if(mapInputFile == NULL)
	{
		fprintf(stderr, "**** issue **** error opening %s\n", mapInputName);
		exit(EXIT_FAILURE);
	}

	// read mapInputFile into mapBuffer array
	char textInput[textMaxLength];

	int mapBuffer[mapMaxLength];
	int mapBufferIndex = 0;

	while((fgets(textInput, textMaxLength, mapInputFile)) && (mapBufferIndex < mapMaxLength -1)) // 1 less than mapMaxLength to leave room for the end marker
	{
		// if textInput from mapInputFile is not a comment or a blank line
		if((textInput[0] != ';') && (textInput[0] != '\n') && (textInput[0] != '\r'))
		{
			// then add it to the mapBuffer as an address
			mapBuffer[mapBufferIndex] = strtol(textInput, NULL, 16);
			mapBufferIndex++;
		}
	}

	// close mapInputFile
	fclose(mapInputFile);

	// mark the end of the mapBuffer array
	mapBuffer[mapBufferIndex] = mapEnd;

	// check that theres at least 2 entry's in the mapBuffer array
	if(mapBufferIndex < 2)
	{
		fprintf(stderr, "**** issue **** %s needs at least two entry's 1) code start address, 2) disassembly start address\n", mapInputName);
		exit(EXIT_FAILURE);
	}

	// get the code start and end address
	codeStart = mapBuffer[0];
	codeEnd = codeStart + binInputSize;

	// check code start address is valid
	if(codeStart < 0 || codeStart > 0xffff)
	{
		fprintf(stderr, "**** issue **** %s start address is outside of the 64K memory range\n", mapInputName);
		exit(EXIT_FAILURE);
	}

	// check code end address is valid
	if(codeEnd < 0 || codeEnd > 0xffff)
	{
		fprintf(stderr, "**** issue **** %s end address is outside of the 64K memory range\n", mapInputName);
		exit(EXIT_FAILURE);
	}



	//---------------------------------------------------------
	// first pass trace the code paths and generate trace file
	//---------------------------------------------------------

	// open trace file writing
	FILE *traceFile = fopen(traceOutputName, "w");
	if(traceFile == NULL)
	{
		fprintf(stderr, "**** issue **** error creating %s\n", traceOutputName);
		exit(EXIT_FAILURE);
	}

	// header
	fprintf(traceFile, "; %s - Z80 Disassembler by LoveBug - %s - %s\n", version, traceOutputName, ctime(&dateAndTime));

	// start at first mapBuffer entry
	mapBufferIndex = 1;

	// loop through mapBuffer's until end is found
	while(mapBuffer[mapBufferIndex] != mapEnd)
	{
		// check that the address is valid
		if(mapBuffer[mapBufferIndex] < codeStart || mapBuffer[mapBufferIndex] >= codeStart + binInputSize)
		{
			fprintf(stderr, "**** issue **** %s address %04x is outside the valid range %04x-%04x\n", mapInputName, mapBuffer[mapBufferIndex], codeStart, codeEnd - 1);
			exit(EXIT_FAILURE);
		}

		// add address label flag
		markBuffer[mapBuffer[mapBufferIndex] - codeStart] |= markJump;

		// trace code and send to traceFile
		printf("Tracing %04x\n", mapBuffer[mapBufferIndex]);
		disassemble(traceFile, mapBuffer[mapBufferIndex], modeTrace);

		// proceed to next mapBuffer
		mapBufferIndex++;
	}

	// close trace file
	fclose(traceFile);

	// trace done
	printf("%s complete\n", traceOutputName);



	//------------------------------------------------------------------------
	// clear any data flags that are not needed
	//------------------------------------------------------------------------

	printf("Removing duplicate address markers\n");
	for(int i=0; i < codeBufferSize; i++)
	{
		// if location is marked as opcode or jump then clear the data mark
		if ((markBuffer[i] & markOpcode) != 0 || (markBuffer[i] & markJump) != 0)
		{
			markBuffer[i] &= ~markData;
		}
	}



	//------------------------------------------------------------------------
	// second pass disassemble from start to finish generating output listing
	//------------------------------------------------------------------------

	// open assemblerOutputName for writing
	FILE *outputFile = fopen(assemblerOutputName, "w");
	if(outputFile == NULL)
	{
		fprintf(stderr, "**** issue **** error creating %s\n", assemblerOutputName);
		exit(EXIT_FAILURE);
	}

	// header
	fprintf(outputFile, "; %s - Z80 Disassembler by LoveBug - %s - %s\n", version, assemblerOutputName, ctime(&dateAndTime));

	// write origin
	fprintf(outputFile, ".org $%04x\n\n", codeStart);

	// generate output disassembly
	printf("Disassembling\n");
	disassemble(outputFile, codeStart, modeGenerate);

	// close output
	fclose(outputFile);

	// disassembly done
	printf("%s complete\n", assemblerOutputName);

	// exit
	exit(EXIT_SUCCESS);
}
